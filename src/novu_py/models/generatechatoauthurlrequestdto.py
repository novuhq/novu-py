"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from novu_py.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class GenerateChatOauthURLRequestDtoContext2TypedDict(TypedDict):
    r"""Rich context object with id and optional data"""

    id: str
    data: NotRequired[Dict[str, Any]]
    r"""Optional additional context data"""


class GenerateChatOauthURLRequestDtoContext2(BaseModel):
    r"""Rich context object with id and optional data"""

    id: str

    data: Optional[Dict[str, Any]] = None
    r"""Optional additional context data"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["data"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


GenerateChatOauthURLRequestDtoContextTypedDict = TypeAliasType(
    "GenerateChatOauthURLRequestDtoContextTypedDict",
    Union[GenerateChatOauthURLRequestDtoContext2TypedDict, str],
)


GenerateChatOauthURLRequestDtoContext = TypeAliasType(
    "GenerateChatOauthURLRequestDtoContext",
    Union[GenerateChatOauthURLRequestDtoContext2, str],
)


class GenerateChatOauthURLRequestDtoTypedDict(TypedDict):
    integration_identifier: str
    r"""Integration identifier"""
    subscriber_id: NotRequired[str]
    r"""The subscriber ID to link the channel connection to. For Slack: Required for incoming webhook endpoints, optional for workspace connections. For MS Teams: Optional. Admin consent is tenant-wide and can be associated with a subscriber for organizational purposes."""
    connection_identifier: NotRequired[str]
    r"""Identifier of the channel connection that will be created. It is generated automatically if not provided."""
    context: NotRequired[Dict[str, GenerateChatOauthURLRequestDtoContextTypedDict]]
    scope: NotRequired[List[str]]
    r"""**Slack only**: OAuth scopes to request during authorization. These define the permissions your Slack integration will have. If not specified, default scopes will be used: chat:write, chat:write.public, channels:read, groups:read, users:read, users:read.email. **MS Teams**: This parameter is ignored. MS Teams uses admin consent with pre-configured permissions in Azure AD. Note: The generated OAuth URL expires after 5 minutes."""


class GenerateChatOauthURLRequestDto(BaseModel):
    integration_identifier: Annotated[
        str, pydantic.Field(alias="integrationIdentifier")
    ]
    r"""Integration identifier"""

    subscriber_id: Annotated[Optional[str], pydantic.Field(alias="subscriberId")] = None
    r"""The subscriber ID to link the channel connection to. For Slack: Required for incoming webhook endpoints, optional for workspace connections. For MS Teams: Optional. Admin consent is tenant-wide and can be associated with a subscriber for organizational purposes."""

    connection_identifier: Annotated[
        Optional[str], pydantic.Field(alias="connectionIdentifier")
    ] = None
    r"""Identifier of the channel connection that will be created. It is generated automatically if not provided."""

    context: Optional[Dict[str, GenerateChatOauthURLRequestDtoContext]] = None

    scope: Optional[List[str]] = None
    r"""**Slack only**: OAuth scopes to request during authorization. These define the permissions your Slack integration will have. If not specified, default scopes will be used: chat:write, chat:write.public, channels:read, groups:read, users:read, users:read.email. **MS Teams**: This parameter is ignored. MS Teams uses admin consent with pre-configured permissions in Azure AD. Note: The generated OAuth URL expires after 5 minutes."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["subscriberId", "connectionIdentifier", "context", "scope"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
